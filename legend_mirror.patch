*** Begin Patch
*** Update File: src/components/map/map-component.js
@@
 // Set map when loaded
 useEffect(() => {
   if (loaded && mapRef.current) {
-    setMap(mapRef.current.getMap());
+    const m = mapRef.current.getMap();
+    setMap(m);
+    // Expose to other components (e.g., Chapter legend resolver)
+    window.__MAP__ = m;
+    // Keep reference valid if the style changes
+    m.on('styledata', () => { window.__MAP__ = m; });
   }
   return undefined;
 }, [mapRef, loaded, setMap]);
*** End Patch
*** Begin Patch
*** Update File: src/components/chapter/chapter.js
@@
-const renderLegend = (legend, sources) => (
-  <div className="text-base leading-6">
-    {legend.map((l) => (
-      <div key={l.title} className="flex items-center gap-4 mb-4">
-        {l.icon ? (
-          <LegendIcon icon={l.icon} />
-        ) : (
-          <span
-            className="legendItem w-8 h-8 mr-4"
-            style={{
-              backgroundColor: l.color,
-              border: l.border ? `solid 2px ${l.border}` : 'none',
-            }}
-          />
-        )}
-        <span>{t(l.title)}</span>
-      </div>
-    ))}
-    {sources && (
-      <div className="ml-12">
-        {t('Sources')}: {t(sources)}
-      </div>
-    )}
-  </div>
-);
+// Mirror live Mapbox layer paint into legend when an item provides `fromLayer`
+function resolveLegendItem(l) {
+  const map = typeof window !== 'undefined' ? window.__MAP__ : undefined;
+  if (!map || !l?.fromLayer) return l;
+
+  const layer = map.getLayer(l.fromLayer);
+  if (!layer) return l;
+
+  const get = (prop) => {
+    try { return map.getPaintProperty(l.fromLayer, prop); }
+    catch { return undefined; }
+  };
+
+  if (layer.type === 'line') {
+    return {
+      ...l,
+      symbol: 'line',
+      color: get('line-color') ?? l.color ?? '#000',
+      width: get('line-width') ?? l.width ?? 3,
+      dasharray: get('line-dasharray') ?? l.dasharray,
+    };
+  }
+  if (layer.type === 'fill') {
+    return {
+      ...l,
+      symbol: 'fill',
+      color: get('fill-color') ?? l.color ?? '#000',
+      border: get('fill-outline-color') ?? l.border,
+    };
+  }
+  if (layer.type === 'circle') {
+    return {
+      ...l,
+      symbol: 'circle',
+      color: get('circle-color') ?? l.color ?? '#000',
+      width: get('circle-radius') ?? l.width ?? 6,
+    };
+  }
+  return l;
+}
+
+const renderLegend = (legend, sources) => {
+  const resolved = legend?.map(resolveLegendItem) ?? [];
+  return (
+    <div className="text-base leading-6">
+      {resolved.map((l) => (
+        <div key={l.title} className="flex items-center gap-4 mb-4">
+          {l.icon ? (
+            <LegendIcon icon={l.icon} />
+          ) : l.symbol === 'line' ? (
+            <svg width="28" height="16" aria-hidden="true" style={{ marginRight: 16 }} role="img" aria-label={t(l.title)}>
+              <line
+                x1="0" y1="8" x2="28" y2="8"
+                stroke={l.color}
+                strokeWidth={l.width ?? 3}
+                strokeDasharray={l.dasharray ? l.dasharray.join(' ') : undefined}
+                strokeLinecap="round"
+                vectorEffect="non-scaling-stroke"
+              />
+            </svg>
+          ) : (
+            <span
+              className="legendItem w-8 h-8 mr-4"
+              style={{
+                // accept hex or gradient strings
+                background: l.color,
+                border: l.border ? `solid 2px ${l.border}` : 'none',
+              }}
+              aria-hidden="true"
+            />
+          )}
+          <span>{t(l.title)}</span>
+        </div>
+      ))}
+      {sources && (
+        <div className="ml-12">
+          {t('Sources')}: {t(sources)}
+        </div>
+      )}
+    </div>
+  );
+};
*** End Patch
